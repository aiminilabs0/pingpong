<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pingpong Rubber Chart</title>
    <link rel="stylesheet" href="main.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <script src="data.js"></script>
</head>
<body>

<div class="lang-switch" aria-label="Country">
    <span class="select-wrap">
        <select id="countrySelect" aria-label="Country">
            <option value="kr">ðŸ‡°ðŸ‡· Korea</option>
            <option value="us">ðŸ‡ºðŸ‡¸ USA</option>
        </select>
    </span>
</div>

<div class="chart-container">
    <div class="tabs" role="tablist" aria-label="Brand" id="brandTabs">
        <button class="tab active" type="button" role="tab" aria-selected="true" data-brand="Butterfly">
            <img src="images/butterfly.ico" alt="" aria-hidden="true" />
            <span data-i18n="brandButterfly">Butterfly</span>
        </button>
        <button class="tab" type="button" role="tab" aria-selected="false" data-brand="Tibhar">
            <img src="images/tibhar.png" alt="" aria-hidden="true" />
            <span data-i18n="brandTibhar">Tibhar</span>
        </button>
        <button class="tab" type="button" role="tab" aria-selected="false" data-brand="XIOM">
            <img src="images/xiom.png" alt="" aria-hidden="true" />
            <span data-i18n="brandXiom">XIOM</span>
        </button>
    </div>
    <div class="canvas-wrap">
        <canvas id="rubberChart"></canvas>
        <div class="hardness-legend" aria-hidden="true">
            <div class="content">
                <div class="row">
                    <span class="bar" data-i18n="legendHardness">Hardness</span>
                </div>
                <div class="example">
                    <div class="ex-line">
                        <span class="country flag" title="Germany">ðŸ‡©ðŸ‡ª</span>
                        <div class="nums">
                            <span class="n left">40</span>
                            <span class="n mid">47.5</span>
                            <span class="n right">55</span>
                        </div>
                    </div>
                    <div class="ex-line">
                        <span class="country flag" title="Japan">ðŸ‡¯ðŸ‡µ</span>
                        <div class="nums">
                            <span class="n left">33</span>
                            <span class="n mid">36</span>
                            <span class="n right">44</span>
                        </div>
                    </div>
                    <div class="ex-line">
                        <span class="country flag" title="China">ðŸ‡¨ðŸ‡³</span>
                        <div class="nums">
                            <span class="n left">35</span>
                            <span class="n mid">39</span>
                            <span class="n right">41</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="shape-legend" aria-hidden="true">
            <div class="row">
                <span class="marker circle"></span>
                <span data-i18n="legendPimplesIn">Pimples-in</span>
            </div>
            <div class="row">
                <span class="marker rectRot"></span>
                <span data-i18n="legendHybrid">Hybrid</span>
            </div>
        </div>
    </div>
</div>

<script>
    // --- i18n (EN/KR) ---
    const I18N = {
        en: {
            pageTitle: 'Pingpong Rubber Chart',
            ariaBrandTabs: 'Brand',
            brandButterfly: 'Butterfly',
            brandTibhar: 'Tibhar',
            brandXiom: 'XIOM',
            legendHardness: 'Hardness',
            legendPimplesIn: 'Pimples-in',
            legendHybrid: 'Hybrid',
            axisSpin: 'Spin',
            axisSpeed: 'Speed',
            tooltipSpinSpeed: 'Spin: {spin}, Speed: {speed}',
            tooltipType: 'Type',
            tooltipArc: 'Arc',
            tooltipThickness: 'Thickness',
            tooltipSheetColors: 'Sheet colors',
            tooltipStrategy: 'Strategy',
            tooltipControl: 'Control',
            tooltipWeight: 'Weight',
            tooltipHardness: 'Hardness',
            tooltipPlayer: 'Player',
            iconSale: 'Sale',
            iconYouTube: 'YouTube'
        },
        ko: {
            pageTitle: 'íƒêµ¬ ëŸ¬ë²„ ì°¨íŠ¸',
            ariaBrandTabs: 'ë¸Œëžœë“œ',
            brandButterfly: 'ë²„í„°í”Œë¼ì´',
            brandTibhar: 'í‹°ë°”',
            brandXiom: 'ì—‘ì‹œì˜´',
            legendHardness: 'ê²½ë„',
            legendPimplesIn: 'í‰ë©´ëŸ¬ë²„',
            legendHybrid: 'í•˜ì´ë¸Œë¦¬ë“œ',
            axisSpin: 'íšŒì „',
            axisSpeed: 'ìŠ¤í”¼ë“œ',
            tooltipSpinSpeed: 'íšŒì „: {spin}, ìŠ¤í”¼ë“œ: {speed}',
            tooltipType: 'íƒ€ìž…',
            tooltipArc: 'ê¶¤ë„',
            tooltipThickness: 'ë‘ê»˜',
            tooltipSheetColors: 'ì‹œíŠ¸ ìƒ‰ìƒ',
            tooltipStrategy: 'ìŠ¤íƒ€ì¼',
            tooltipControl: 'ì»¨íŠ¸ë¡¤',
            tooltipWeight: 'ë¬´ê²Œ',
            tooltipHardness: 'ê²½ë„',
            tooltipPlayer: 'ì„ ìˆ˜',
            iconSale: 'êµ¬ë§¤',
            iconYouTube: 'ìœ íŠœë¸Œ'
        }
    };

    const COUNTRY_TO_LANG = {
        kr: 'ko',
        us: 'en',
    };

    function detectDefaultCountry() {
        const nav = (navigator.language || '').toLowerCase();
        return nav.startsWith('ko') ? 'kr' : 'us';
    }

    function normalizeCountry(country) {
        return COUNTRY_TO_LANG[country] ? country : 'us';
    }

    let currentCountry = window.localStorage.getItem('country');
    if (!currentCountry) {
        // Back-compat: old storage key was "lang" with values "ko" / "en".
        const legacyLang = window.localStorage.getItem('lang');
        if (legacyLang === 'ko') currentCountry = 'kr';
        else if (legacyLang === 'en') currentCountry = 'us';
    }
    currentCountry = normalizeCountry(currentCountry || detectDefaultCountry());

    let currentLang = COUNTRY_TO_LANG[currentCountry] || 'en';
    if (!I18N[currentLang]) currentLang = 'en';

    function t(key, vars) {
        const table = I18N[currentLang] || I18N.en;
        let s = table[key] ?? I18N.en[key] ?? key;
        if (vars && typeof s === 'string') {
            for (const [k, v] of Object.entries(vars)) {
                s = s.replaceAll(`{${k}}`, String(v));
            }
        }
        return s;
    }

    function localizeBrandName(brand) {
        if (brand === 'Butterfly') return t('brandButterfly');
        if (brand === 'Tibhar') return t('brandTibhar');
        if (brand === 'XIOM') return t('brandXiom');
        return brand;
    }

    function localizeRubberName(name) {
        const s = typeof name === 'string' ? name : '';
        if (!s) return '';
        if (currentLang !== 'ko') return s;
        return RUBBER_NAME_KO[s] ?? s;
    }

    function applyCountryToDom() {
        document.documentElement.lang = currentLang;
        document.title = t('pageTitle');

        const brandTabs = document.getElementById('brandTabs');
        if (brandTabs) brandTabs.setAttribute('aria-label', t('ariaBrandTabs'));

        document.querySelectorAll('[data-i18n]').forEach((el) => {
            const key = el.getAttribute('data-i18n');
            if (!key) return;
            el.textContent = t(key);
        });
        const select = document.getElementById('countrySelect');
        if (select && select.value !== currentCountry) select.value = currentCountry;
    }

    function applyLanguageToChart(chart) {
        if (!chart?.options?.scales) return;
        if (chart.options.scales.x?.title) chart.options.scales.x.title.text = t('axisSpin');
        if (chart.options.scales.y?.title) chart.options.scales.y.title.text = t('axisSpeed');
        chart.update();
    }

    function setCountry(country, chart, tooltipEl) {
        if (!COUNTRY_TO_LANG[country]) return;
        currentCountry = country;
        currentLang = COUNTRY_TO_LANG[currentCountry] || 'en';
        window.localStorage.setItem('country', currentCountry);
        // Optional: keep derived language in sync for back-compat.
        window.localStorage.setItem('lang', currentLang);
        applyCountryToDom();
        applyLanguageToChart(chart);
        if (tooltipEl) tooltipEl.style.display = 'none';
    }

    // --- 1. Consolidated Data ---
    // We store color and shape directly with the data point to keep the visual distinction
    // while using only one dataset.

    // Brand-specific knobs (easy to replace later)
    const BUTTERFLY = 'Butterfly';
    const BUTTERFLY_ICON = 'images/butterfly.ico';

    const TIBHAR = 'Tibhar';
    const TIBHAR_ICON = 'images/tibhar.png';

    const XIOM = 'XIOM';
    const XIOM_ICON = 'images/xiom.png';

    // Axis ranges per brand (used by the tabs).
    // Tune these numbers if you want a tighter/looser zoom per brand.
    const BRAND_AXIS_RANGES = {
        // Butterfly includes everything from classic control rubbers to modern high-tension.
        [BUTTERFLY]: { xMin: 55,  xMax: 105, yMin: 60,  yMax: 95 },
        [TIBHAR]:    { xMin: 110, xMax: 135, yMin: 110, yMax: 135 },
        [XIOM]:      { xMin: 30,  xMax: 90, yMin: 40,  yMax: 80 },
    };

    // Normal Rubber (Orange) - shade by hardness (higher hardness => darker)
    const NORMAL_RUBBER_ULTRA_LIGHT = '#FFE0B2'; // Very light orange / pastel
    const NORMAL_RUBBER_VERY_LIGHT  = '#FFCC80'; // Lighter than LIGHT
    const NORMAL_RUBBER_LIGHT       = '#FFB74D'; // Light
    const NORMAL_RUBBER_COLOR       = '#FF9100'; // Normal
    const NORMAL_RUBBER_DARK        = '#EF6C00'; // Dark

    const NORMAL_RUBBER_SHADES = [
        NORMAL_RUBBER_ULTRA_LIGHT,
        NORMAL_RUBBER_VERY_LIGHT,
        NORMAL_RUBBER_LIGHT,
        NORMAL_RUBBER_COLOR,
        NORMAL_RUBBER_DARK
    ];

    // Company-specific hardness ranges (tweak these as you add more brands).
    // If a brand is missing here, we fall back to min/max computed from the brand's dataset.
    const BRAND_HARDNESS_RANGES = {
        [BUTTERFLY]: { min: 32, max: 44 },
        [TIBHAR]:    { min: 40, max: 55 },
        [XIOM]:      { min: 40, max: 55 },
    };

    function parseHardness(h) {
        if (typeof h === 'number' && Number.isFinite(h)) return h;
        if (typeof h === 'string') {
            const n = Number.parseFloat(h.trim());
            return Number.isFinite(n) ? n : null;
        }
        return null;
    }

    function computeHardnessRange(data) {
        let min = Infinity;
        let max = -Infinity;
        for (const d of data) {
            const h = parseHardness(d?.hardness);
            if (h == null) continue;
            if (h < min) min = h;
            if (h > max) max = h;
        }
        if (!Number.isFinite(min) || !Number.isFinite(max)) return null;
        return { min, max };
    }

    function clamp01(t) {
        if (t < 0) return 0;
        if (t > 1) return 1;
        return t;
    }

    function shadeFromHardness(h, range) {
        if (h == null || !range) return NORMAL_RUBBER_COLOR;
        const denom = (range.max - range.min);
        const t = denom === 0 ? 0.5 : clamp01((h - range.min) / denom);
        const idx = Math.round(t * (NORMAL_RUBBER_SHADES.length - 1));
        return NORMAL_RUBBER_SHADES[idx] ?? NORMAL_RUBBER_COLOR;
    }

    function colorForRubberPoint(d, brand, brandData) {
        const h = parseHardness(d?.hardness);
        const range = BRAND_HARDNESS_RANGES[brand] ?? computeHardnessRange(brandData);
        return shadeFromHardness(h, range);
    }
    function normalizeUrl(u) {
        return typeof u === 'string' ? u.trim() : '';
    }

    function valueForCountry(v) {
        if (typeof v === 'string') return v;
        if (v && typeof v === 'object') return v[currentCountry] ?? '';
        return '';
    }

    function productUrlForPoint(pointData) {
        return normalizeUrl(valueForCountry(pointData?.productUrlByCountry ?? pointData?.productUrl));
    }

    function youtubeUrlForPoint(pointData) {
        return normalizeUrl(valueForCountry(pointData?.youtubeUrlByCountry ?? pointData?.youtubeUrl));
    }

    // Swap shapes:
    // - circle -> rectRot
    // - rect   -> circle
    function mapPointStyle(shape) {
        if (shape === 'hybrid') return 'rectRot';
        if (shape === 'normal') return 'circle';
        return shape ?? 'normal';
    }
    
    // --- 2. Chart Setup ---
    const ctx = document.getElementById('rubberChart').getContext('2d');

    // Keep the bottom-right "shape legend" aligned to the chart's *plot area* (chartArea),
    // not the full canvas (which includes extra right padding for labels).
    const overlayAlignPlugin = {
        id: 'overlayAlignPlugin',
        afterLayout(chart) {
            const wrap = chart?.canvas?.closest?.('.canvas-wrap');
            if (!wrap || !chart?.chartArea) return;

            const shapeLegend = wrap.querySelector('.shape-legend');
            if (!shapeLegend) return;

            const cs = getComputedStyle(shapeLegend);
            const padRight = parseFloat(cs.paddingRight) || 0;
            const insetRight = (chart.width - chart.chartArea.right) || 0;

            // We want the *text* to end at chartArea.right, which is inside the legend box by `paddingRight`.
            const right = Math.max(0, insetRight - padRight);
            shapeLegend.style.right = `${right}px`;
        }
    };

    const butterflyDataset = {
        label: BUTTERFLY, // Single Category Name
        data: butterflyRubbers,
        // Map the styles from the data array
        pointBackgroundColor: butterflyRubbers.map(d => colorForRubberPoint(d, BUTTERFLY, butterflyRubbers)),
        pointBorderColor: butterflyRubbers.map(d => colorForRubberPoint(d, BUTTERFLY, butterflyRubbers)),
        pointStyle: butterflyRubbers.map(d => mapPointStyle(d.shape)),
        pointRadius: 7,
        pointHoverRadius: 9
    };

    const tibharDataset = {
        label: TIBHAR,
        data: tibharRubbers,
        pointBackgroundColor: tibharRubbers.map(d => colorForRubberPoint(d, TIBHAR, tibharRubbers)),
        pointBorderColor: tibharRubbers.map(d => colorForRubberPoint(d, TIBHAR, tibharRubbers)),
        pointStyle: tibharRubbers.map(d => mapPointStyle(d.shape ?? 'normal')),
        pointRadius: 7,
        pointHoverRadius: 9
    };

    const xiomDataset = {
        label: XIOM,
        data: xiomRubbers,
        pointBackgroundColor: xiomRubbers.map(d => colorForRubberPoint(d, XIOM, xiomRubbers)),
        pointBorderColor: xiomRubbers.map(d => colorForRubberPoint(d, XIOM, xiomRubbers)),
        pointStyle: xiomRubbers.map(d => mapPointStyle(d.shape ?? 'normal')),
        pointRadius: 7,
        pointHoverRadius: 9
    };

    const chart = new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: [
                butterflyDataset,
                tibharDataset,
                xiomDataset
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
                // Extra bottom padding prevents the x-axis title from getting clipped.
                padding: { top: 20, right: 20, bottom: 56, left: 20 }
            },
            scales: {
                x: {
                    display: true,
                    min: 40,
                    max: 100,
                    ticks: {
                        display: true,
                        color: 'rgba(255,255,255,0.55)',
                        padding: 8
                    },
                    title: {
                        display: true,
                        text: t('axisSpin'),
                        font: { size: 16, weight: 'normal' },
                        color: 'rgba(255,255,255,0.88)',
                        padding: { top: 10 }
                    },
                    grid: {
                        color: 'rgba(255,255,255,0.10)',
                        lineWidth: 1
                    }
                },
                y: {
                    display: true,
                    min: 40,
                    max: 100,
                    ticks: {
                        display: true,
                        color: 'rgba(255,255,255,0.55)',
                        padding: 8
                    },
                    title: {
                        display: true,
                        text: t('axisSpeed'),
                        font: { size: 16, weight: 'normal' },
                        color: 'rgba(255,255,255,0.88)'
                    },
                    grid: {
                        color: 'rgba(255,255,255,0.10)',
                        lineWidth: 1
                    }
                }
            },
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    enabled: false,
                    external: function(context) {
                        externalTooltipHandler(context);
                    }
                },
                datalabels: {
                    // Always place the label immediately to the right of the point (dot).
                    align: 'right',
                    anchor: 'center',
                    offset: 8,
                    color: 'rgba(255,255,255,0.88)',
                    font: { size: 11, weight: 'normal' },
                    textAlign: 'left',
                    clamp: true,
                    formatter: function(value) {
                        return localizeRubberName(value.label);
                    }
                }
            },
            // --- 3. Click Event Handler ---
            onClick: (evt, activeElements, chart) => {
                if (activeElements.length > 0) {
                    const datasetIndex = activeElements[0].datasetIndex;
                    const dataIndex = activeElements[0].index;
                    const ds = chart.data.datasets[datasetIndex];
                    const pointData = ds.data[dataIndex];

                    const product = productUrlForPoint(pointData);
                    const youtube = youtubeUrlForPoint(pointData);
                    if (product) {
                        window.open(product, '_blank');
                    } else if (youtube) {
                        openYouTubeEmbed(youtube);
                    }
                }
            }
        },
        plugins: [ChartDataLabels, overlayAlignPlugin]
    });

    // --- HTML tooltip (clickable links) ---
    const canvasWrapEl = document.querySelector('.canvas-wrap');
    const tooltipEl = document.createElement('div');
    tooltipEl.className = 'chart-tooltip';
    canvasWrapEl.appendChild(tooltipEl);

    let tooltipPinned = false;
    let hideTooltipTimer = null;
    tooltipEl.addEventListener('mouseenter', () => {
        tooltipPinned = true;
        if (hideTooltipTimer) {
            window.clearTimeout(hideTooltipTimer);
            hideTooltipTimer = null;
        }
    });
    tooltipEl.addEventListener('mouseleave', () => {
        tooltipPinned = false;
        if (hideTooltipTimer) window.clearTimeout(hideTooltipTimer);
        hideTooltipTimer = window.setTimeout(() => {
            tooltipEl.style.display = 'none';
        }, 50);
    });

    function clearEl(el) {
        while (el.firstChild) el.removeChild(el.firstChild);
    }

    // --- YouTube embed (in-page) ---
    function isYouTubeUrl(u) {
        try {
            const url = new URL(u);
            const h = url.hostname.replace(/^www\./, '');
            return h === 'youtube.com' || h === 'm.youtube.com' || h === 'youtu.be' || h.endsWith('.youtube.com');
        } catch {
            return false;
        }
    }

    function parseStartSeconds(u) {
        try {
            const url = new URL(u);
            const t = url.searchParams.get('t') || url.searchParams.get('start');
            if (!t) return 0;
            // Supports "90", "90s", "1m30s", "1h2m3s"
            if (/^\d+$/.test(t)) return parseInt(t, 10);
            let s = 0;
            const m = String(t).match(/(?:(\d+)h)?(?:(\d+)m)?(?:(\d+)s)?/i);
            if (!m) return 0;
            if (m[1]) s += parseInt(m[1], 10) * 3600;
            if (m[2]) s += parseInt(m[2], 10) * 60;
            if (m[3]) s += parseInt(m[3], 10);
            return Number.isFinite(s) ? s : 0;
        } catch {
            return 0;
        }
    }

    function toYouTubeEmbedUrl(u) {
        try {
            const url = new URL(u);
            const host = url.hostname.replace(/^www\./, '');
            let id = '';
            if (host === 'youtu.be') {
                id = url.pathname.split('/').filter(Boolean)[0] || '';
            } else {
                // /watch?v=ID
                id = url.searchParams.get('v') || '';
                // /shorts/ID or /embed/ID
                if (!id) {
                    const parts = url.pathname.split('/').filter(Boolean);
                    if (parts[0] === 'shorts' && parts[1]) id = parts[1];
                    if (parts[0] === 'embed' && parts[1]) id = parts[1];
                }
            }
            if (!id) return null;
            const start = parseStartSeconds(u);
            // Use privacy-enhanced mode to reduce cookie/consent issues in embeds.
            const embed = new URL(`https://www.youtube-nocookie.com/embed/${encodeURIComponent(id)}`);
            embed.searchParams.set('autoplay', '1');
            embed.searchParams.set('rel', '0');
            embed.searchParams.set('modestbranding', '1');
            embed.searchParams.set('playsinline', '1');
            if (start > 0) embed.searchParams.set('start', String(start));
            // Some environments require origin to avoid "player configuration" errors.
            if (typeof location !== 'undefined' && location.origin && location.origin !== 'null') {
                embed.searchParams.set('origin', location.origin);
            }
            return embed.toString();
        } catch {
            return null;
        }
    }

    function ensureYouTubeOverlay() {
        let overlay = document.getElementById('ytOverlay');
        if (overlay) return overlay;

        overlay = document.createElement('div');
        overlay.id = 'ytOverlay';
        overlay.className = 'yt-overlay';
        overlay.setAttribute('role', 'dialog');
        overlay.setAttribute('aria-modal', 'true');
        overlay.setAttribute('aria-label', 'YouTube player');

        const modal = document.createElement('div');
        modal.className = 'yt-modal';

        const head = document.createElement('div');
        head.className = 'yt-modal-head';

        const title = document.createElement('div');
        title.className = 'yt-modal-title';
        // Intentionally blank: user requested no visible "YouTube" text in the overlay header.
        title.textContent = '';

        const closeBtn = document.createElement('button');
        closeBtn.className = 'yt-close';
        closeBtn.type = 'button';
        closeBtn.textContent = 'Close';

        const openLink = document.createElement('a');
        openLink.className = 'yt-open';
        openLink.textContent = 'Open on YouTube';
        openLink.target = '_blank';
        openLink.rel = 'noopener noreferrer';
        openLink.href = '#';

        const frameWrap = document.createElement('div');
        frameWrap.className = 'yt-frame';
        const iframe = document.createElement('iframe');
        iframe.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share');
        iframe.setAttribute('allowfullscreen', '');
        iframe.setAttribute('referrerpolicy', 'strict-origin-when-cross-origin');
        iframe.setAttribute('title', 'YouTube video player');
        frameWrap.appendChild(iframe);

        head.appendChild(title);
        head.appendChild(openLink);
        head.appendChild(closeBtn);
        modal.appendChild(head);
        modal.appendChild(frameWrap);
        overlay.appendChild(modal);
        document.body.appendChild(overlay);

        function closeOverlay() {
            overlay.classList.remove('open');
            iframe.src = ''; // stop playback
        }

        overlay.addEventListener('click', (e) => {
            // click outside modal closes
            if (e.target === overlay) closeOverlay();
        });
        closeBtn.addEventListener('click', closeOverlay);
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && overlay.classList.contains('open')) closeOverlay();
        });

        overlay._yt = { iframe, title, closeOverlay, openLink };
        return overlay;
    }

    function openYouTubeEmbed(originalUrl) {
        const embedUrl = toYouTubeEmbedUrl(originalUrl);
        if (!embedUrl) return false;
        const overlay = ensureYouTubeOverlay();
        overlay._yt.title.textContent = '';
        overlay._yt.openLink.href = originalUrl;
        overlay._yt.iframe.src = embedUrl;
        overlay.classList.add('open');
        return true;
    }

    function maybeEmbedYouTubeClick(e, url) {
        // Only intercept normal left-clicks (keep ctrl/cmd-click & middle-click working)
        if (!isYouTubeUrl(url)) return false;
        if (e.button !== 0) return false;
        if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) return false;
        e.preventDefault();
        e.stopPropagation();
        return openYouTubeEmbed(url);
    }

    function makeLink(label, url) {
        const u = normalizeUrl(url);
        if (!u) return null;
        const a = document.createElement('a');
        a.href = u;
        a.target = '_blank';
        a.rel = 'noopener noreferrer';
        a.textContent = label;
        return a;
    }

    function makeIconLink(iconSrc, altText, url) {
        const u = normalizeUrl(url);
        if (!u) return null;
        const a = document.createElement('a');
        a.href = u;
        a.target = '_blank';
        a.rel = 'noopener noreferrer';
        a.className = 'icon-link';
        a.setAttribute('aria-label', altText);
        const img = document.createElement('img');
        img.src = iconSrc;
        img.alt = altText;
        a.appendChild(img);
        if (isYouTubeUrl(u)) {
            a.dataset.youtubeUrl = u;
            a.addEventListener('click', (e) => maybeEmbedYouTubeClick(e, u));
        }
        return a;
    }

    function externalTooltipHandler(context) {
        const { chart, tooltip } = context;

        // If the tooltip should be hidden, only hide if the user isn't hovering the tooltip itself.
        if (tooltip.opacity === 0) {
            if (tooltipPinned) return;

            // Give the user a small window to move from the point to the tooltip to click links.
            if (hideTooltipTimer) window.clearTimeout(hideTooltipTimer);
            hideTooltipTimer = window.setTimeout(() => {
                if (!tooltipPinned) tooltipEl.style.display = 'none';
            }, 350);
            return;
        }

        if (hideTooltipTimer) {
            window.clearTimeout(hideTooltipTimer);
            hideTooltipTimer = null;
        }

        // Populate content from the hovered point.
        const dp = tooltip?.dataPoints?.[0];
        const r = dp?.raw ?? {};
        clearEl(tooltipEl);

        const title = document.createElement('div');
        title.className = 't';
        title.textContent = `${localizeRubberName(r.label ?? '')}`;
        tooltipEl.appendChild(title);

        const rows = [];
        if (r.type) rows.push(`${t('tooltipType')}: ${r.type}`);
        if (typeof r.arc === 'number') rows.push(`${t('tooltipArc')}: ${r.arc}`);
        if (r.thickness) rows.push(`${t('tooltipThickness')}: ${r.thickness}`);
        if (Array.isArray(r.sheetColors) && r.sheetColors.length > 0) rows.push(`${t('tooltipSheetColors')}: ${r.sheetColors.join(' / ')}`);
        if (r.strategy) rows.push(`${t('tooltipStrategy')}: ${r.strategy}`);
        if (typeof r.control === 'number') rows.push(`${t('tooltipControl')}: ${r.control}`);
        if (r.weight) rows.push(`${t('tooltipWeight')}: ${r.weight}`);
        if (r.hardness) rows.push(`${t('tooltipHardness')}: ${r.hardness}`);
        if (r.player) rows.push(`${t('tooltipPlayer')}: ${r.player}`);

        rows.forEach((txt) => {
            const row = document.createElement('div');
            row.className = 'row';
            row.textContent = txt;
            tooltipEl.appendChild(row);
        });

        const links = document.createElement('div');
        links.className = 'links';
        const product = productUrlForPoint(r);
        const youtube = youtubeUrlForPoint(r);
        const aShop = makeIconLink('images/sale.png', t('iconSale'), product);
        const aYt = makeIconLink('images/youtube.ico', t('iconYouTube'), youtube);
        if (aShop) links.appendChild(aShop);
        if (aYt) links.appendChild(aYt);
        if (links.childNodes.length > 0) tooltipEl.appendChild(links);

        // Position near the cursor (within canvas-wrap, which is positioned).
        const wrapRect = canvasWrapEl.getBoundingClientRect();
        const left = Math.min(
            tooltip.caretX + 12,
            wrapRect.width - 12
        );
        const top = Math.min(
            tooltip.caretY + 12,
            wrapRect.height - 12
        );
        tooltipEl.style.left = `${left}px`;
        tooltipEl.style.top = `${top}px`;
        tooltipEl.style.display = 'block';
    }

    function setActiveBrand(brand) {
        // Ensure exactly one brand is visible.
        chart.setDatasetVisibility(0, brand === BUTTERFLY);
        chart.setDatasetVisibility(1, brand === TIBHAR);
        chart.setDatasetVisibility(2, brand === XIOM);

        // Apply brand-specific axis ranges.
        const r = BRAND_AXIS_RANGES[brand];
        if (r) {
            chart.options.scales.x.min = r.xMin;
            chart.options.scales.x.max = r.xMax;
            chart.options.scales.y.min = r.yMin;
            chart.options.scales.y.max = r.yMax;
        }

        chart.update();

        // Update tab UI.
        const tabs = document.querySelectorAll('.tab[data-brand]');
        tabs.forEach((btn) => {
            const isActive = btn.getAttribute('data-brand') === brand;
            btn.classList.toggle('active', isActive);
            btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
        });
    }

    // Default to Butterfly.
    setActiveBrand(BUTTERFLY);

    // Country switch init + handlers.
    applyCountryToDom();
    applyLanguageToChart(chart);
    const countrySelect = document.getElementById('countrySelect');
    if (countrySelect) {
        countrySelect.addEventListener('change', () => {
            const country = countrySelect.value;
            if (!country) return;
            setCountry(country, chart, tooltipEl);
        });
    }

    // Tab click handlers.
    document.querySelectorAll('.tab[data-brand]').forEach((btn) => {
        btn.addEventListener('click', () => {
            const brand = btn.getAttribute('data-brand');
            if (brand && BRAND_AXIS_RANGES[brand]) setActiveBrand(brand);
        });
    });

</script>

</body>
</html> 